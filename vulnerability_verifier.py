from z3 import Solver, sat, BitVecVal, BitVec, unsat, BitVecNumRef, And
from data_structures import Storage
from collections import defaultdict
from utils import *
import time_measurement
from time import time
from constant import *


class VulnerabilityVerifier:
    def __init__(self):
        self.independently_executed_state = dict()
        self.ies_path_condition = True
        self.cross_called_executed_state = dict()
        self.cces_path_condition = True
        self.caller_state = dict()
        self.ies_depth = 0
        self.cces_depth = 0
        self.caller_state_depth = 0

        self.function_ids = set()
        self.callable_function_ids = set()
        self.extracting_fid = False
        self.executing_caller = False
        self.executing_callee = False
        self.executing_cross_function = False

        self.first_call = False
        self.second_call = False
        self.third_call = False
        self.x = None
        self.y = None

    def init_states(self):
        self.independently_executed_state = dict()
        self.cross_called_executed_state = dict()
        self.caller_state = dict()
        self.ies_depth = 0
        self.cces_depth = 0
        self.caller_state_depth = 0

    def add_state_to_ies(self, storage: Storage, balance, condition):
        dict = storage.get_data()

        dict["BALANCE"] = balance
        dict["PATH_CONDITION"] = condition

        self.independently_executed_state[condition] = dict

    def add_state_to_cces(self, storage: Storage, balance, condition):
        dict = storage.get_data()

        dict["BALANCE"] = balance
        dict["PATH_CONDITION"] = condition
        self.cross_called_executed_state[condition] = dict

    def add_caller_state(self, storage: Storage, balance, condition):

        dict = storage.get_data()
        dict["BALANCE"] = balance
        dict["PATH_CONDITION"] = condition
        if self.caller_state_depth > depth:
            dict.update(self.caller_state)
            self.caller_state = dict
        else:
            self.caller_state.update(dict)
            self.caller_state_depth = depth

    def get_caller_state(self):
        return Storage(storage_data=self.caller_state)

    def get_function_ids(self) -> set:
        return self.function_ids

    def get_callable_function_ids(self) -> set:
        return self.callable_function_ids

    def diff_states(self):
        C1 = list(self.cross_called_executed_state.keys())
        C2 = list(self.independently_executed_state.keys())
        for i, c1 in enumerate(C1):
            vulnerable = True
            pair = None
            for j, c2 in enumerate(C2):
                m = get_model_and_time(And(c1 != c2))
                print(i, j, m)
                if not m:
                    pair = c2
                    vulnerable = False
                    break

            if vulnerable:
                return True
            else:
                C2.remove(pair)

        return False

    def extract_function_id(self, condition, block_state):
        if self.extracting_fid:
            m = get_model_and_time(condition)
            if m:
                fid = m[BitVec("function_id", 32)]
                # the case contract has only one function
                if fid is None:
                    self.function_ids.add(BitVecVal(0, 32))
                    if "callable" in block_state:
                        self.callable_function_ids.add(BitVecVal(0, 32))

                else:
                    self.function_ids.add(fid)
                    if "callable" in block_state:
                        self.callable_function_ids.add(fid)
                    return True

        return False

    def set_extracting_fid(self):
        self.extracting_fid = True
        self.executing_caller = False
        self.executing_callee = False
        self.executing_cross_function = False

    def set_executing_caller(self):
        self.extracting_fid = False
        self.executing_caller = True
        self.executing_callee = False
        self.executing_cross_function = False

    def set_executing_callee(self):
        self.extracting_fid = False
        self.executing_caller = False
        self.executing_callee = True
        self.executing_cross_function = False

    def set_executing_cross_function(self):
        self.extracting_fid = False
        self.executing_caller = False
        self.executing_callee = False
        self.executing_cross_function = True

    def extract_data(self, condition, block_state, storage, balance):
        if self.extracting_fid:
            self.extract_function_id(condition, block_state)
        elif self.executing_callee:
            self.add_state_to_ies(storage, balance, condition)
        elif self.executing_cross_function and CALLABLE in block_state:
            self.add_state_to_cces(storage, balance, condition)

    def is_first_call(self):
        if self.first_call:
            self.first_call = False
            return True
        else:
            return False

    def is_second_call(self):
        if not self.first_call and self.second_call:
            self.second_call = False
            return True
        else:
            return False

    def is_third_call(self):
        if not self.second_call and self.third_call:
            self.third_call = False
            return True
        else:
            return False

    def set_first_call(self, b):
        self.first_call = b

    def set_second_call(self, b):
        self.second_call = b

    def set_third_call(self, b):
        self.third_call = b

    def set_x(self, x):
        self.x = x

    def set_y(self, y):
        self.y = y

    def get_x(self):
        return self.x

    def get_y(self):
        return self.y

    def extract_data_before_call(
        self, condition, block_state, storage, balance, depth,
    ):
        pass

    def extract_data_with_callback(
        self, condition, block_state, storage, balance, depth,
    ):
        pass


class VulenerabilityVerifierBeforeCall(VulnerabilityVerifier):
    def extract_data(
        self, condition, block_state, storage, balance, depth,
    ):
        if self.extracting_fid:
            self.extract_function_id(condition, block_state)
        elif self.executing_caller:
            self.add_caller_state(storage, balance, depth, condition)

    def extract_data_before_call(self, condition, block_state, storage, balance, depth):
        if self.executing_callee and self.is_first_call():
            self.add_state_to_ies(storage, balance, depth, condition)
        elif self.executing_cross_function and self.is_third_call():
            self.add_state_to_cces(storage, balance, depth, condition)


class VulnerabilityVerifierAfterCall(VulnerabilityVerifier):
    def extract_data(
        self, condition, block_state, storage, balance, depth,
    ):
        if self.extracting_fid:
            self.extract_function_id(condition, block_state)
        elif self.executing_caller:
            self.add_caller_state(storage, balance, depth, condition)
        elif self.executing_callee:
            self.add_state_to_ies(storage, balance, depth, condition)
        # elif self.executing_cross_function and self.is_third_call():
        #     self.add_state_to_cces(storage, balance, depth, condition)

    def extract_data_before_call(
        self, condition, block_state, storage, balance, depth,
    ):
        pass

    def extract_data_with_callback(
        self, condition, block_state, storage, balance, depth,
    ):
        if self.executing_cross_function and self.is_third_call():
            self.add_state_to_cces(storage, balance, depth, condition)
